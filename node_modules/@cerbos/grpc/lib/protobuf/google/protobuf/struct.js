"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// source: google/protobuf/struct.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListValue = exports.Value = exports.Struct_FieldsEntry = exports.Struct = exports.NullValue = exports.protobufPackage = void 0;
/* eslint-disable */
const wire_1 = require("@bufbuild/protobuf/wire");
exports.protobufPackage = "google.protobuf";
var NullValue;
(function (NullValue) {
    NullValue[NullValue["NULL_VALUE"] = 0] = "NULL_VALUE";
})(NullValue || (exports.NullValue = NullValue = {}));
function createBaseStruct() {
    return { fields: {} };
}
exports.Struct = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        Object.entries(message.fields).forEach(([key, value]) => {
            if (value !== undefined) {
                exports.Struct_FieldsEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
            }
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStruct();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = exports.Struct_FieldsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.fields[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    wrap(object) {
        const struct = createBaseStruct();
        if (object !== undefined) {
            for (const key of Object.keys(object)) {
                struct.fields[key] = object[key];
            }
        }
        return struct;
    },
    unwrap(message) {
        const object = {};
        if (message.fields) {
            for (const key of Object.keys(message.fields)) {
                object[key] = message.fields[key];
            }
        }
        return object;
    },
};
function createBaseStruct_FieldsEntry() {
    return { key: "", value: undefined };
}
exports.Struct_FieldsEntry = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.Value.encode(exports.Value.wrap(message.value), writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStruct_FieldsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = exports.Value.unwrap(exports.Value.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseValue() {
    return { kind: undefined };
}
exports.Value = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        switch (message.kind?.$case) {
            case "nullValue":
                writer.uint32(8).int32(message.kind.nullValue);
                break;
            case "numberValue":
                writer.uint32(17).double(message.kind.numberValue);
                break;
            case "stringValue":
                writer.uint32(26).string(message.kind.stringValue);
                break;
            case "boolValue":
                writer.uint32(32).bool(message.kind.boolValue);
                break;
            case "structValue":
                exports.Struct.encode(exports.Struct.wrap(message.kind.structValue), writer.uint32(42).fork()).join();
                break;
            case "listValue":
                exports.ListValue.encode(exports.ListValue.wrap(message.kind.listValue), writer.uint32(50).fork()).join();
                break;
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.kind = {
                        $case: "nullValue",
                        nullValue: reader.int32(),
                    };
                    continue;
                }
                case 2: {
                    if (tag !== 17) {
                        break;
                    }
                    message.kind = { $case: "numberValue", numberValue: reader.double() };
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.kind = { $case: "stringValue", stringValue: reader.string() };
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.kind = { $case: "boolValue", boolValue: reader.bool() };
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.kind = {
                        $case: "structValue",
                        structValue: exports.Struct.unwrap(exports.Struct.decode(reader, reader.uint32())),
                    };
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.kind = {
                        $case: "listValue",
                        listValue: exports.ListValue.unwrap(exports.ListValue.decode(reader, reader.uint32())),
                    };
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    wrap(value) {
        const result = createBaseValue();
        if (value === null) {
            result.kind = { $case: "nullValue", nullValue: NullValue.NULL_VALUE };
        }
        else if (typeof value === "boolean") {
            result.kind = { $case: "boolValue", boolValue: value };
        }
        else if (typeof value === "number") {
            result.kind = { $case: "numberValue", numberValue: value };
        }
        else if (typeof value === "string") {
            result.kind = { $case: "stringValue", stringValue: value };
        }
        else if (globalThis.Array.isArray(value)) {
            result.kind = { $case: "listValue", listValue: value };
        }
        else if (typeof value === "object") {
            result.kind = { $case: "structValue", structValue: value };
        }
        else if (typeof value !== "undefined") {
            throw new globalThis.Error("Unsupported any value type: " + typeof value);
        }
        return result;
    },
    unwrap(message) {
        if (message.kind?.$case === "nullValue") {
            return null;
        }
        else if (message.kind?.$case === "numberValue") {
            return message.kind?.numberValue;
        }
        else if (message.kind?.$case === "stringValue") {
            return message.kind?.stringValue;
        }
        else if (message.kind?.$case === "boolValue") {
            return message.kind?.boolValue;
        }
        else if (message.kind?.$case === "structValue") {
            return message.kind?.structValue;
        }
        else if (message.kind?.$case === "listValue") {
            return message.kind?.listValue;
        }
        else {
            return undefined;
        }
    },
};
function createBaseListValue() {
    return { values: [] };
}
exports.ListValue = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.values) {
            exports.Value.encode(exports.Value.wrap(v), writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.values.push(exports.Value.unwrap(exports.Value.decode(reader, reader.uint32())));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    wrap(array) {
        const result = createBaseListValue();
        result.values = array ?? [];
        return result;
    },
    unwrap(message) {
        if (message?.hasOwnProperty("values") &&
            globalThis.Array.isArray(message.values)) {
            return message.values;
        }
        else {
            return message;
        }
    },
};
//# sourceMappingURL=struct.js.map