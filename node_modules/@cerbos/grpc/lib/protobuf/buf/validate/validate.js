"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// source: buf/validate/validate.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimestampRules = exports.DurationRules = exports.AnyRules = exports.MapRules = exports.RepeatedRules = exports.EnumRules = exports.BytesRules = exports.StringRules = exports.BoolRules = exports.SFixed64Rules = exports.SFixed32Rules = exports.Fixed64Rules = exports.Fixed32Rules = exports.SInt64Rules = exports.SInt32Rules = exports.UInt64Rules = exports.UInt32Rules = exports.Int64Rules = exports.Int32Rules = exports.DoubleRules = exports.FloatRules = exports.PredefinedRules = exports.FieldRules = exports.OneofRules = exports.MessageRules = exports.Rule = exports.KnownRegex = exports.Ignore = exports.protobufPackage = void 0;
/* eslint-disable */
const wire_1 = require("@bufbuild/protobuf/wire");
const duration_1 = require("../../google/protobuf/duration");
const timestamp_1 = require("../../google/protobuf/timestamp");
exports.protobufPackage = "buf.validate";
var Ignore;
(function (Ignore) {
    Ignore[Ignore["IGNORE_UNSPECIFIED"] = 0] = "IGNORE_UNSPECIFIED";
    Ignore[Ignore["IGNORE_IF_UNPOPULATED"] = 1] = "IGNORE_IF_UNPOPULATED";
    Ignore[Ignore["IGNORE_IF_DEFAULT_VALUE"] = 2] = "IGNORE_IF_DEFAULT_VALUE";
    Ignore[Ignore["IGNORE_ALWAYS"] = 3] = "IGNORE_ALWAYS";
})(Ignore || (exports.Ignore = Ignore = {}));
var KnownRegex;
(function (KnownRegex) {
    KnownRegex[KnownRegex["KNOWN_REGEX_UNSPECIFIED"] = 0] = "KNOWN_REGEX_UNSPECIFIED";
    KnownRegex[KnownRegex["KNOWN_REGEX_HTTP_HEADER_NAME"] = 1] = "KNOWN_REGEX_HTTP_HEADER_NAME";
    KnownRegex[KnownRegex["KNOWN_REGEX_HTTP_HEADER_VALUE"] = 2] = "KNOWN_REGEX_HTTP_HEADER_VALUE";
})(KnownRegex || (exports.KnownRegex = KnownRegex = {}));
function createBaseRule() {
    return { id: "", message: "", expression: "" };
}
exports.Rule = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== undefined && message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.message !== undefined && message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        if (message.expression !== undefined && message.expression !== "") {
            writer.uint32(26).string(message.expression);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRule();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.expression = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseMessageRules() {
    return { disabled: false, cel: [] };
}
exports.MessageRules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.disabled !== undefined && message.disabled !== false) {
            writer.uint32(8).bool(message.disabled);
        }
        for (const v of message.cel) {
            exports.Rule.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.disabled = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.cel.push(exports.Rule.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseOneofRules() {
    return { required: false };
}
exports.OneofRules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.required !== undefined && message.required !== false) {
            writer.uint32(8).bool(message.required);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOneofRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.required = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseFieldRules() {
    return { cel: [], required: false, ignore: 0, type: undefined };
}
exports.FieldRules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.cel) {
            exports.Rule.encode(v, writer.uint32(186).fork()).join();
        }
        if (message.required !== undefined && message.required !== false) {
            writer.uint32(200).bool(message.required);
        }
        if (message.ignore !== undefined && message.ignore !== 0) {
            writer.uint32(216).int32(message.ignore);
        }
        switch (message.type?.$case) {
            case "float":
                exports.FloatRules.encode(message.type.float, writer.uint32(10).fork()).join();
                break;
            case "double":
                exports.DoubleRules.encode(message.type.double, writer.uint32(18).fork()).join();
                break;
            case "int32":
                exports.Int32Rules.encode(message.type.int32, writer.uint32(26).fork()).join();
                break;
            case "int64":
                exports.Int64Rules.encode(message.type.int64, writer.uint32(34).fork()).join();
                break;
            case "uint32":
                exports.UInt32Rules.encode(message.type.uint32, writer.uint32(42).fork()).join();
                break;
            case "uint64":
                exports.UInt64Rules.encode(message.type.uint64, writer.uint32(50).fork()).join();
                break;
            case "sint32":
                exports.SInt32Rules.encode(message.type.sint32, writer.uint32(58).fork()).join();
                break;
            case "sint64":
                exports.SInt64Rules.encode(message.type.sint64, writer.uint32(66).fork()).join();
                break;
            case "fixed32":
                exports.Fixed32Rules.encode(message.type.fixed32, writer.uint32(74).fork()).join();
                break;
            case "fixed64":
                exports.Fixed64Rules.encode(message.type.fixed64, writer.uint32(82).fork()).join();
                break;
            case "sfixed32":
                exports.SFixed32Rules.encode(message.type.sfixed32, writer.uint32(90).fork()).join();
                break;
            case "sfixed64":
                exports.SFixed64Rules.encode(message.type.sfixed64, writer.uint32(98).fork()).join();
                break;
            case "bool":
                exports.BoolRules.encode(message.type.bool, writer.uint32(106).fork()).join();
                break;
            case "string":
                exports.StringRules.encode(message.type.string, writer.uint32(114).fork()).join();
                break;
            case "bytes":
                exports.BytesRules.encode(message.type.bytes, writer.uint32(122).fork()).join();
                break;
            case "enum":
                exports.EnumRules.encode(message.type.enum, writer.uint32(130).fork()).join();
                break;
            case "repeated":
                exports.RepeatedRules.encode(message.type.repeated, writer.uint32(146).fork()).join();
                break;
            case "map":
                exports.MapRules.encode(message.type.map, writer.uint32(154).fork()).join();
                break;
            case "any":
                exports.AnyRules.encode(message.type.any, writer.uint32(162).fork()).join();
                break;
            case "duration":
                exports.DurationRules.encode(message.type.duration, writer.uint32(170).fork()).join();
                break;
            case "timestamp":
                exports.TimestampRules.encode(message.type.timestamp, writer.uint32(178).fork()).join();
                break;
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFieldRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 23: {
                    if (tag !== 186) {
                        break;
                    }
                    message.cel.push(exports.Rule.decode(reader, reader.uint32()));
                    continue;
                }
                case 25: {
                    if (tag !== 200) {
                        break;
                    }
                    message.required = reader.bool();
                    continue;
                }
                case 27: {
                    if (tag !== 216) {
                        break;
                    }
                    message.ignore = reader.int32();
                    continue;
                }
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.type = {
                        $case: "float",
                        float: exports.FloatRules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.type = {
                        $case: "double",
                        double: exports.DoubleRules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.type = {
                        $case: "int32",
                        int32: exports.Int32Rules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.type = {
                        $case: "int64",
                        int64: exports.Int64Rules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.type = {
                        $case: "uint32",
                        uint32: exports.UInt32Rules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.type = {
                        $case: "uint64",
                        uint64: exports.UInt64Rules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.type = {
                        $case: "sint32",
                        sint32: exports.SInt32Rules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.type = {
                        $case: "sint64",
                        sint64: exports.SInt64Rules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.type = {
                        $case: "fixed32",
                        fixed32: exports.Fixed32Rules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    message.type = {
                        $case: "fixed64",
                        fixed64: exports.Fixed64Rules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 11: {
                    if (tag !== 90) {
                        break;
                    }
                    message.type = {
                        $case: "sfixed32",
                        sfixed32: exports.SFixed32Rules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 12: {
                    if (tag !== 98) {
                        break;
                    }
                    message.type = {
                        $case: "sfixed64",
                        sfixed64: exports.SFixed64Rules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 13: {
                    if (tag !== 106) {
                        break;
                    }
                    message.type = {
                        $case: "bool",
                        bool: exports.BoolRules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 14: {
                    if (tag !== 114) {
                        break;
                    }
                    message.type = {
                        $case: "string",
                        string: exports.StringRules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 15: {
                    if (tag !== 122) {
                        break;
                    }
                    message.type = {
                        $case: "bytes",
                        bytes: exports.BytesRules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 16: {
                    if (tag !== 130) {
                        break;
                    }
                    message.type = {
                        $case: "enum",
                        enum: exports.EnumRules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 18: {
                    if (tag !== 146) {
                        break;
                    }
                    message.type = {
                        $case: "repeated",
                        repeated: exports.RepeatedRules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 19: {
                    if (tag !== 154) {
                        break;
                    }
                    message.type = {
                        $case: "map",
                        map: exports.MapRules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 20: {
                    if (tag !== 162) {
                        break;
                    }
                    message.type = {
                        $case: "any",
                        any: exports.AnyRules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 21: {
                    if (tag !== 170) {
                        break;
                    }
                    message.type = {
                        $case: "duration",
                        duration: exports.DurationRules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 22: {
                    if (tag !== 178) {
                        break;
                    }
                    message.type = {
                        $case: "timestamp",
                        timestamp: exports.TimestampRules.decode(reader, reader.uint32()),
                    };
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBasePredefinedRules() {
    return { cel: [] };
}
exports.PredefinedRules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.cel) {
            exports.Rule.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePredefinedRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.cel.push(exports.Rule.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseFloatRules() {
    return {
        const: 0,
        lessThan: undefined,
        greaterThan: undefined,
        in: [],
        notIn: [],
        finite: false,
        example: [],
    };
}
exports.FloatRules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined && message.const !== 0) {
            writer.uint32(13).float(message.const);
        }
        switch (message.lessThan?.$case) {
            case "lt":
                writer.uint32(21).float(message.lessThan.lt);
                break;
            case "lte":
                writer.uint32(29).float(message.lessThan.lte);
                break;
        }
        switch (message.greaterThan?.$case) {
            case "gt":
                writer.uint32(37).float(message.greaterThan.gt);
                break;
            case "gte":
                writer.uint32(45).float(message.greaterThan.gte);
                break;
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.float(v);
        }
        writer.join();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.float(v);
        }
        writer.join();
        if (message.finite !== undefined && message.finite !== false) {
            writer.uint32(64).bool(message.finite);
        }
        writer.uint32(74).fork();
        for (const v of message.example) {
            writer.float(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFloatRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 13) {
                        break;
                    }
                    message.const = reader.float();
                    continue;
                }
                case 2: {
                    if (tag !== 21) {
                        break;
                    }
                    message.lessThan = { $case: "lt", lt: reader.float() };
                    continue;
                }
                case 3: {
                    if (tag !== 29) {
                        break;
                    }
                    message.lessThan = { $case: "lte", lte: reader.float() };
                    continue;
                }
                case 4: {
                    if (tag !== 37) {
                        break;
                    }
                    message.greaterThan = { $case: "gt", gt: reader.float() };
                    continue;
                }
                case 5: {
                    if (tag !== 45) {
                        break;
                    }
                    message.greaterThan = { $case: "gte", gte: reader.float() };
                    continue;
                }
                case 6: {
                    if (tag === 53) {
                        message.in.push(reader.float());
                        continue;
                    }
                    if (tag === 50) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.float());
                        }
                        continue;
                    }
                    break;
                }
                case 7: {
                    if (tag === 61) {
                        message.notIn.push(reader.float());
                        continue;
                    }
                    if (tag === 58) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.float());
                        }
                        continue;
                    }
                    break;
                }
                case 8: {
                    if (tag !== 64) {
                        break;
                    }
                    message.finite = reader.bool();
                    continue;
                }
                case 9: {
                    if (tag === 77) {
                        message.example.push(reader.float());
                        continue;
                    }
                    if (tag === 74) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.example.push(reader.float());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseDoubleRules() {
    return {
        const: 0,
        lessThan: undefined,
        greaterThan: undefined,
        in: [],
        notIn: [],
        finite: false,
        example: [],
    };
}
exports.DoubleRules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined && message.const !== 0) {
            writer.uint32(9).double(message.const);
        }
        switch (message.lessThan?.$case) {
            case "lt":
                writer.uint32(17).double(message.lessThan.lt);
                break;
            case "lte":
                writer.uint32(25).double(message.lessThan.lte);
                break;
        }
        switch (message.greaterThan?.$case) {
            case "gt":
                writer.uint32(33).double(message.greaterThan.gt);
                break;
            case "gte":
                writer.uint32(41).double(message.greaterThan.gte);
                break;
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.double(v);
        }
        writer.join();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.double(v);
        }
        writer.join();
        if (message.finite !== undefined && message.finite !== false) {
            writer.uint32(64).bool(message.finite);
        }
        writer.uint32(74).fork();
        for (const v of message.example) {
            writer.double(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDoubleRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 9) {
                        break;
                    }
                    message.const = reader.double();
                    continue;
                }
                case 2: {
                    if (tag !== 17) {
                        break;
                    }
                    message.lessThan = { $case: "lt", lt: reader.double() };
                    continue;
                }
                case 3: {
                    if (tag !== 25) {
                        break;
                    }
                    message.lessThan = { $case: "lte", lte: reader.double() };
                    continue;
                }
                case 4: {
                    if (tag !== 33) {
                        break;
                    }
                    message.greaterThan = { $case: "gt", gt: reader.double() };
                    continue;
                }
                case 5: {
                    if (tag !== 41) {
                        break;
                    }
                    message.greaterThan = { $case: "gte", gte: reader.double() };
                    continue;
                }
                case 6: {
                    if (tag === 49) {
                        message.in.push(reader.double());
                        continue;
                    }
                    if (tag === 50) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.double());
                        }
                        continue;
                    }
                    break;
                }
                case 7: {
                    if (tag === 57) {
                        message.notIn.push(reader.double());
                        continue;
                    }
                    if (tag === 58) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.double());
                        }
                        continue;
                    }
                    break;
                }
                case 8: {
                    if (tag !== 64) {
                        break;
                    }
                    message.finite = reader.bool();
                    continue;
                }
                case 9: {
                    if (tag === 73) {
                        message.example.push(reader.double());
                        continue;
                    }
                    if (tag === 74) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.example.push(reader.double());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseInt32Rules() {
    return {
        const: 0,
        lessThan: undefined,
        greaterThan: undefined,
        in: [],
        notIn: [],
        example: [],
    };
}
exports.Int32Rules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined && message.const !== 0) {
            writer.uint32(8).int32(message.const);
        }
        switch (message.lessThan?.$case) {
            case "lt":
                writer.uint32(16).int32(message.lessThan.lt);
                break;
            case "lte":
                writer.uint32(24).int32(message.lessThan.lte);
                break;
        }
        switch (message.greaterThan?.$case) {
            case "gt":
                writer.uint32(32).int32(message.greaterThan.gt);
                break;
            case "gte":
                writer.uint32(40).int32(message.greaterThan.gte);
                break;
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.int32(v);
        }
        writer.join();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.int32(v);
        }
        writer.join();
        writer.uint32(66).fork();
        for (const v of message.example) {
            writer.int32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInt32Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.const = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.lessThan = { $case: "lt", lt: reader.int32() };
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.lessThan = { $case: "lte", lte: reader.int32() };
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.greaterThan = { $case: "gt", gt: reader.int32() };
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.greaterThan = { $case: "gte", gte: reader.int32() };
                    continue;
                }
                case 6: {
                    if (tag === 48) {
                        message.in.push(reader.int32());
                        continue;
                    }
                    if (tag === 50) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 7: {
                    if (tag === 56) {
                        message.notIn.push(reader.int32());
                        continue;
                    }
                    if (tag === 58) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 8: {
                    if (tag === 64) {
                        message.example.push(reader.int32());
                        continue;
                    }
                    if (tag === 66) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.example.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseInt64Rules() {
    return {
        const: "0",
        lessThan: undefined,
        greaterThan: undefined,
        in: [],
        notIn: [],
        example: [],
    };
}
exports.Int64Rules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined && message.const !== "0") {
            writer.uint32(8).int64(message.const);
        }
        switch (message.lessThan?.$case) {
            case "lt":
                writer.uint32(16).int64(message.lessThan.lt);
                break;
            case "lte":
                writer.uint32(24).int64(message.lessThan.lte);
                break;
        }
        switch (message.greaterThan?.$case) {
            case "gt":
                writer.uint32(32).int64(message.greaterThan.gt);
                break;
            case "gte":
                writer.uint32(40).int64(message.greaterThan.gte);
                break;
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.int64(v);
        }
        writer.join();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.int64(v);
        }
        writer.join();
        writer.uint32(74).fork();
        for (const v of message.example) {
            writer.int64(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInt64Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.const = reader.int64().toString();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.lessThan = { $case: "lt", lt: reader.int64().toString() };
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.lessThan = { $case: "lte", lte: reader.int64().toString() };
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.greaterThan = { $case: "gt", gt: reader.int64().toString() };
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.greaterThan = {
                        $case: "gte",
                        gte: reader.int64().toString(),
                    };
                    continue;
                }
                case 6: {
                    if (tag === 48) {
                        message.in.push(reader.int64().toString());
                        continue;
                    }
                    if (tag === 50) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.int64().toString());
                        }
                        continue;
                    }
                    break;
                }
                case 7: {
                    if (tag === 56) {
                        message.notIn.push(reader.int64().toString());
                        continue;
                    }
                    if (tag === 58) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.int64().toString());
                        }
                        continue;
                    }
                    break;
                }
                case 9: {
                    if (tag === 72) {
                        message.example.push(reader.int64().toString());
                        continue;
                    }
                    if (tag === 74) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.example.push(reader.int64().toString());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseUInt32Rules() {
    return {
        const: 0,
        lessThan: undefined,
        greaterThan: undefined,
        in: [],
        notIn: [],
        example: [],
    };
}
exports.UInt32Rules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined && message.const !== 0) {
            writer.uint32(8).uint32(message.const);
        }
        switch (message.lessThan?.$case) {
            case "lt":
                writer.uint32(16).uint32(message.lessThan.lt);
                break;
            case "lte":
                writer.uint32(24).uint32(message.lessThan.lte);
                break;
        }
        switch (message.greaterThan?.$case) {
            case "gt":
                writer.uint32(32).uint32(message.greaterThan.gt);
                break;
            case "gte":
                writer.uint32(40).uint32(message.greaterThan.gte);
                break;
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.uint32(v);
        }
        writer.join();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.uint32(v);
        }
        writer.join();
        writer.uint32(66).fork();
        for (const v of message.example) {
            writer.uint32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUInt32Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.const = reader.uint32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.lessThan = { $case: "lt", lt: reader.uint32() };
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.lessThan = { $case: "lte", lte: reader.uint32() };
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.greaterThan = { $case: "gt", gt: reader.uint32() };
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.greaterThan = { $case: "gte", gte: reader.uint32() };
                    continue;
                }
                case 6: {
                    if (tag === 48) {
                        message.in.push(reader.uint32());
                        continue;
                    }
                    if (tag === 50) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.uint32());
                        }
                        continue;
                    }
                    break;
                }
                case 7: {
                    if (tag === 56) {
                        message.notIn.push(reader.uint32());
                        continue;
                    }
                    if (tag === 58) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.uint32());
                        }
                        continue;
                    }
                    break;
                }
                case 8: {
                    if (tag === 64) {
                        message.example.push(reader.uint32());
                        continue;
                    }
                    if (tag === 66) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.example.push(reader.uint32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseUInt64Rules() {
    return {
        const: "0",
        lessThan: undefined,
        greaterThan: undefined,
        in: [],
        notIn: [],
        example: [],
    };
}
exports.UInt64Rules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined && message.const !== "0") {
            writer.uint32(8).uint64(message.const);
        }
        switch (message.lessThan?.$case) {
            case "lt":
                writer.uint32(16).uint64(message.lessThan.lt);
                break;
            case "lte":
                writer.uint32(24).uint64(message.lessThan.lte);
                break;
        }
        switch (message.greaterThan?.$case) {
            case "gt":
                writer.uint32(32).uint64(message.greaterThan.gt);
                break;
            case "gte":
                writer.uint32(40).uint64(message.greaterThan.gte);
                break;
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.uint64(v);
        }
        writer.join();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.uint64(v);
        }
        writer.join();
        writer.uint32(66).fork();
        for (const v of message.example) {
            writer.uint64(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUInt64Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.const = reader.uint64().toString();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.lessThan = { $case: "lt", lt: reader.uint64().toString() };
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.lessThan = { $case: "lte", lte: reader.uint64().toString() };
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.greaterThan = { $case: "gt", gt: reader.uint64().toString() };
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.greaterThan = {
                        $case: "gte",
                        gte: reader.uint64().toString(),
                    };
                    continue;
                }
                case 6: {
                    if (tag === 48) {
                        message.in.push(reader.uint64().toString());
                        continue;
                    }
                    if (tag === 50) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.uint64().toString());
                        }
                        continue;
                    }
                    break;
                }
                case 7: {
                    if (tag === 56) {
                        message.notIn.push(reader.uint64().toString());
                        continue;
                    }
                    if (tag === 58) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.uint64().toString());
                        }
                        continue;
                    }
                    break;
                }
                case 8: {
                    if (tag === 64) {
                        message.example.push(reader.uint64().toString());
                        continue;
                    }
                    if (tag === 66) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.example.push(reader.uint64().toString());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseSInt32Rules() {
    return {
        const: 0,
        lessThan: undefined,
        greaterThan: undefined,
        in: [],
        notIn: [],
        example: [],
    };
}
exports.SInt32Rules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined && message.const !== 0) {
            writer.uint32(8).sint32(message.const);
        }
        switch (message.lessThan?.$case) {
            case "lt":
                writer.uint32(16).sint32(message.lessThan.lt);
                break;
            case "lte":
                writer.uint32(24).sint32(message.lessThan.lte);
                break;
        }
        switch (message.greaterThan?.$case) {
            case "gt":
                writer.uint32(32).sint32(message.greaterThan.gt);
                break;
            case "gte":
                writer.uint32(40).sint32(message.greaterThan.gte);
                break;
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.sint32(v);
        }
        writer.join();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.sint32(v);
        }
        writer.join();
        writer.uint32(66).fork();
        for (const v of message.example) {
            writer.sint32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSInt32Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.const = reader.sint32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.lessThan = { $case: "lt", lt: reader.sint32() };
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.lessThan = { $case: "lte", lte: reader.sint32() };
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.greaterThan = { $case: "gt", gt: reader.sint32() };
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.greaterThan = { $case: "gte", gte: reader.sint32() };
                    continue;
                }
                case 6: {
                    if (tag === 48) {
                        message.in.push(reader.sint32());
                        continue;
                    }
                    if (tag === 50) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.sint32());
                        }
                        continue;
                    }
                    break;
                }
                case 7: {
                    if (tag === 56) {
                        message.notIn.push(reader.sint32());
                        continue;
                    }
                    if (tag === 58) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.sint32());
                        }
                        continue;
                    }
                    break;
                }
                case 8: {
                    if (tag === 64) {
                        message.example.push(reader.sint32());
                        continue;
                    }
                    if (tag === 66) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.example.push(reader.sint32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseSInt64Rules() {
    return {
        const: "0",
        lessThan: undefined,
        greaterThan: undefined,
        in: [],
        notIn: [],
        example: [],
    };
}
exports.SInt64Rules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined && message.const !== "0") {
            writer.uint32(8).sint64(message.const);
        }
        switch (message.lessThan?.$case) {
            case "lt":
                writer.uint32(16).sint64(message.lessThan.lt);
                break;
            case "lte":
                writer.uint32(24).sint64(message.lessThan.lte);
                break;
        }
        switch (message.greaterThan?.$case) {
            case "gt":
                writer.uint32(32).sint64(message.greaterThan.gt);
                break;
            case "gte":
                writer.uint32(40).sint64(message.greaterThan.gte);
                break;
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.sint64(v);
        }
        writer.join();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.sint64(v);
        }
        writer.join();
        writer.uint32(66).fork();
        for (const v of message.example) {
            writer.sint64(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSInt64Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.const = reader.sint64().toString();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.lessThan = { $case: "lt", lt: reader.sint64().toString() };
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.lessThan = { $case: "lte", lte: reader.sint64().toString() };
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.greaterThan = { $case: "gt", gt: reader.sint64().toString() };
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.greaterThan = {
                        $case: "gte",
                        gte: reader.sint64().toString(),
                    };
                    continue;
                }
                case 6: {
                    if (tag === 48) {
                        message.in.push(reader.sint64().toString());
                        continue;
                    }
                    if (tag === 50) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.sint64().toString());
                        }
                        continue;
                    }
                    break;
                }
                case 7: {
                    if (tag === 56) {
                        message.notIn.push(reader.sint64().toString());
                        continue;
                    }
                    if (tag === 58) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.sint64().toString());
                        }
                        continue;
                    }
                    break;
                }
                case 8: {
                    if (tag === 64) {
                        message.example.push(reader.sint64().toString());
                        continue;
                    }
                    if (tag === 66) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.example.push(reader.sint64().toString());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseFixed32Rules() {
    return {
        const: 0,
        lessThan: undefined,
        greaterThan: undefined,
        in: [],
        notIn: [],
        example: [],
    };
}
exports.Fixed32Rules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined && message.const !== 0) {
            writer.uint32(13).fixed32(message.const);
        }
        switch (message.lessThan?.$case) {
            case "lt":
                writer.uint32(21).fixed32(message.lessThan.lt);
                break;
            case "lte":
                writer.uint32(29).fixed32(message.lessThan.lte);
                break;
        }
        switch (message.greaterThan?.$case) {
            case "gt":
                writer.uint32(37).fixed32(message.greaterThan.gt);
                break;
            case "gte":
                writer.uint32(45).fixed32(message.greaterThan.gte);
                break;
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.fixed32(v);
        }
        writer.join();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.fixed32(v);
        }
        writer.join();
        writer.uint32(66).fork();
        for (const v of message.example) {
            writer.fixed32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFixed32Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 13) {
                        break;
                    }
                    message.const = reader.fixed32();
                    continue;
                }
                case 2: {
                    if (tag !== 21) {
                        break;
                    }
                    message.lessThan = { $case: "lt", lt: reader.fixed32() };
                    continue;
                }
                case 3: {
                    if (tag !== 29) {
                        break;
                    }
                    message.lessThan = { $case: "lte", lte: reader.fixed32() };
                    continue;
                }
                case 4: {
                    if (tag !== 37) {
                        break;
                    }
                    message.greaterThan = { $case: "gt", gt: reader.fixed32() };
                    continue;
                }
                case 5: {
                    if (tag !== 45) {
                        break;
                    }
                    message.greaterThan = { $case: "gte", gte: reader.fixed32() };
                    continue;
                }
                case 6: {
                    if (tag === 53) {
                        message.in.push(reader.fixed32());
                        continue;
                    }
                    if (tag === 50) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.fixed32());
                        }
                        continue;
                    }
                    break;
                }
                case 7: {
                    if (tag === 61) {
                        message.notIn.push(reader.fixed32());
                        continue;
                    }
                    if (tag === 58) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.fixed32());
                        }
                        continue;
                    }
                    break;
                }
                case 8: {
                    if (tag === 69) {
                        message.example.push(reader.fixed32());
                        continue;
                    }
                    if (tag === 66) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.example.push(reader.fixed32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseFixed64Rules() {
    return {
        const: "0",
        lessThan: undefined,
        greaterThan: undefined,
        in: [],
        notIn: [],
        example: [],
    };
}
exports.Fixed64Rules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined && message.const !== "0") {
            writer.uint32(9).fixed64(message.const);
        }
        switch (message.lessThan?.$case) {
            case "lt":
                writer.uint32(17).fixed64(message.lessThan.lt);
                break;
            case "lte":
                writer.uint32(25).fixed64(message.lessThan.lte);
                break;
        }
        switch (message.greaterThan?.$case) {
            case "gt":
                writer.uint32(33).fixed64(message.greaterThan.gt);
                break;
            case "gte":
                writer.uint32(41).fixed64(message.greaterThan.gte);
                break;
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.fixed64(v);
        }
        writer.join();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.fixed64(v);
        }
        writer.join();
        writer.uint32(66).fork();
        for (const v of message.example) {
            writer.fixed64(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFixed64Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 9) {
                        break;
                    }
                    message.const = reader.fixed64().toString();
                    continue;
                }
                case 2: {
                    if (tag !== 17) {
                        break;
                    }
                    message.lessThan = { $case: "lt", lt: reader.fixed64().toString() };
                    continue;
                }
                case 3: {
                    if (tag !== 25) {
                        break;
                    }
                    message.lessThan = { $case: "lte", lte: reader.fixed64().toString() };
                    continue;
                }
                case 4: {
                    if (tag !== 33) {
                        break;
                    }
                    message.greaterThan = {
                        $case: "gt",
                        gt: reader.fixed64().toString(),
                    };
                    continue;
                }
                case 5: {
                    if (tag !== 41) {
                        break;
                    }
                    message.greaterThan = {
                        $case: "gte",
                        gte: reader.fixed64().toString(),
                    };
                    continue;
                }
                case 6: {
                    if (tag === 49) {
                        message.in.push(reader.fixed64().toString());
                        continue;
                    }
                    if (tag === 50) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.fixed64().toString());
                        }
                        continue;
                    }
                    break;
                }
                case 7: {
                    if (tag === 57) {
                        message.notIn.push(reader.fixed64().toString());
                        continue;
                    }
                    if (tag === 58) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.fixed64().toString());
                        }
                        continue;
                    }
                    break;
                }
                case 8: {
                    if (tag === 65) {
                        message.example.push(reader.fixed64().toString());
                        continue;
                    }
                    if (tag === 66) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.example.push(reader.fixed64().toString());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseSFixed32Rules() {
    return {
        const: 0,
        lessThan: undefined,
        greaterThan: undefined,
        in: [],
        notIn: [],
        example: [],
    };
}
exports.SFixed32Rules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined && message.const !== 0) {
            writer.uint32(13).sfixed32(message.const);
        }
        switch (message.lessThan?.$case) {
            case "lt":
                writer.uint32(21).sfixed32(message.lessThan.lt);
                break;
            case "lte":
                writer.uint32(29).sfixed32(message.lessThan.lte);
                break;
        }
        switch (message.greaterThan?.$case) {
            case "gt":
                writer.uint32(37).sfixed32(message.greaterThan.gt);
                break;
            case "gte":
                writer.uint32(45).sfixed32(message.greaterThan.gte);
                break;
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.sfixed32(v);
        }
        writer.join();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.sfixed32(v);
        }
        writer.join();
        writer.uint32(66).fork();
        for (const v of message.example) {
            writer.sfixed32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSFixed32Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 13) {
                        break;
                    }
                    message.const = reader.sfixed32();
                    continue;
                }
                case 2: {
                    if (tag !== 21) {
                        break;
                    }
                    message.lessThan = { $case: "lt", lt: reader.sfixed32() };
                    continue;
                }
                case 3: {
                    if (tag !== 29) {
                        break;
                    }
                    message.lessThan = { $case: "lte", lte: reader.sfixed32() };
                    continue;
                }
                case 4: {
                    if (tag !== 37) {
                        break;
                    }
                    message.greaterThan = { $case: "gt", gt: reader.sfixed32() };
                    continue;
                }
                case 5: {
                    if (tag !== 45) {
                        break;
                    }
                    message.greaterThan = { $case: "gte", gte: reader.sfixed32() };
                    continue;
                }
                case 6: {
                    if (tag === 53) {
                        message.in.push(reader.sfixed32());
                        continue;
                    }
                    if (tag === 50) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.sfixed32());
                        }
                        continue;
                    }
                    break;
                }
                case 7: {
                    if (tag === 61) {
                        message.notIn.push(reader.sfixed32());
                        continue;
                    }
                    if (tag === 58) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.sfixed32());
                        }
                        continue;
                    }
                    break;
                }
                case 8: {
                    if (tag === 69) {
                        message.example.push(reader.sfixed32());
                        continue;
                    }
                    if (tag === 66) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.example.push(reader.sfixed32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseSFixed64Rules() {
    return {
        const: "0",
        lessThan: undefined,
        greaterThan: undefined,
        in: [],
        notIn: [],
        example: [],
    };
}
exports.SFixed64Rules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined && message.const !== "0") {
            writer.uint32(9).sfixed64(message.const);
        }
        switch (message.lessThan?.$case) {
            case "lt":
                writer.uint32(17).sfixed64(message.lessThan.lt);
                break;
            case "lte":
                writer.uint32(25).sfixed64(message.lessThan.lte);
                break;
        }
        switch (message.greaterThan?.$case) {
            case "gt":
                writer.uint32(33).sfixed64(message.greaterThan.gt);
                break;
            case "gte":
                writer.uint32(41).sfixed64(message.greaterThan.gte);
                break;
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.sfixed64(v);
        }
        writer.join();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.sfixed64(v);
        }
        writer.join();
        writer.uint32(66).fork();
        for (const v of message.example) {
            writer.sfixed64(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSFixed64Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 9) {
                        break;
                    }
                    message.const = reader.sfixed64().toString();
                    continue;
                }
                case 2: {
                    if (tag !== 17) {
                        break;
                    }
                    message.lessThan = { $case: "lt", lt: reader.sfixed64().toString() };
                    continue;
                }
                case 3: {
                    if (tag !== 25) {
                        break;
                    }
                    message.lessThan = {
                        $case: "lte",
                        lte: reader.sfixed64().toString(),
                    };
                    continue;
                }
                case 4: {
                    if (tag !== 33) {
                        break;
                    }
                    message.greaterThan = {
                        $case: "gt",
                        gt: reader.sfixed64().toString(),
                    };
                    continue;
                }
                case 5: {
                    if (tag !== 41) {
                        break;
                    }
                    message.greaterThan = {
                        $case: "gte",
                        gte: reader.sfixed64().toString(),
                    };
                    continue;
                }
                case 6: {
                    if (tag === 49) {
                        message.in.push(reader.sfixed64().toString());
                        continue;
                    }
                    if (tag === 50) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.sfixed64().toString());
                        }
                        continue;
                    }
                    break;
                }
                case 7: {
                    if (tag === 57) {
                        message.notIn.push(reader.sfixed64().toString());
                        continue;
                    }
                    if (tag === 58) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.sfixed64().toString());
                        }
                        continue;
                    }
                    break;
                }
                case 8: {
                    if (tag === 65) {
                        message.example.push(reader.sfixed64().toString());
                        continue;
                    }
                    if (tag === 66) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.example.push(reader.sfixed64().toString());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseBoolRules() {
    return { const: false, example: [] };
}
exports.BoolRules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined && message.const !== false) {
            writer.uint32(8).bool(message.const);
        }
        writer.uint32(18).fork();
        for (const v of message.example) {
            writer.bool(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBoolRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.const = reader.bool();
                    continue;
                }
                case 2: {
                    if (tag === 16) {
                        message.example.push(reader.bool());
                        continue;
                    }
                    if (tag === 18) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.example.push(reader.bool());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseStringRules() {
    return {
        const: "",
        len: "0",
        minLen: "0",
        maxLen: "0",
        lenBytes: "0",
        minBytes: "0",
        maxBytes: "0",
        pattern: "",
        prefix: "",
        suffix: "",
        contains: "",
        notContains: "",
        in: [],
        notIn: [],
        wellKnown: undefined,
        strict: false,
        example: [],
    };
}
exports.StringRules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined && message.const !== "") {
            writer.uint32(10).string(message.const);
        }
        if (message.len !== undefined && message.len !== "0") {
            writer.uint32(152).uint64(message.len);
        }
        if (message.minLen !== undefined && message.minLen !== "0") {
            writer.uint32(16).uint64(message.minLen);
        }
        if (message.maxLen !== undefined && message.maxLen !== "0") {
            writer.uint32(24).uint64(message.maxLen);
        }
        if (message.lenBytes !== undefined && message.lenBytes !== "0") {
            writer.uint32(160).uint64(message.lenBytes);
        }
        if (message.minBytes !== undefined && message.minBytes !== "0") {
            writer.uint32(32).uint64(message.minBytes);
        }
        if (message.maxBytes !== undefined && message.maxBytes !== "0") {
            writer.uint32(40).uint64(message.maxBytes);
        }
        if (message.pattern !== undefined && message.pattern !== "") {
            writer.uint32(50).string(message.pattern);
        }
        if (message.prefix !== undefined && message.prefix !== "") {
            writer.uint32(58).string(message.prefix);
        }
        if (message.suffix !== undefined && message.suffix !== "") {
            writer.uint32(66).string(message.suffix);
        }
        if (message.contains !== undefined && message.contains !== "") {
            writer.uint32(74).string(message.contains);
        }
        if (message.notContains !== undefined && message.notContains !== "") {
            writer.uint32(186).string(message.notContains);
        }
        for (const v of message.in) {
            writer.uint32(82).string(v);
        }
        for (const v of message.notIn) {
            writer.uint32(90).string(v);
        }
        switch (message.wellKnown?.$case) {
            case "email":
                writer.uint32(96).bool(message.wellKnown.email);
                break;
            case "hostname":
                writer.uint32(104).bool(message.wellKnown.hostname);
                break;
            case "ip":
                writer.uint32(112).bool(message.wellKnown.ip);
                break;
            case "ipv4":
                writer.uint32(120).bool(message.wellKnown.ipv4);
                break;
            case "ipv6":
                writer.uint32(128).bool(message.wellKnown.ipv6);
                break;
            case "uri":
                writer.uint32(136).bool(message.wellKnown.uri);
                break;
            case "uriRef":
                writer.uint32(144).bool(message.wellKnown.uriRef);
                break;
            case "address":
                writer.uint32(168).bool(message.wellKnown.address);
                break;
            case "uuid":
                writer.uint32(176).bool(message.wellKnown.uuid);
                break;
            case "tuuid":
                writer.uint32(264).bool(message.wellKnown.tuuid);
                break;
            case "ipWithPrefixlen":
                writer.uint32(208).bool(message.wellKnown.ipWithPrefixlen);
                break;
            case "ipv4WithPrefixlen":
                writer.uint32(216).bool(message.wellKnown.ipv4WithPrefixlen);
                break;
            case "ipv6WithPrefixlen":
                writer.uint32(224).bool(message.wellKnown.ipv6WithPrefixlen);
                break;
            case "ipPrefix":
                writer.uint32(232).bool(message.wellKnown.ipPrefix);
                break;
            case "ipv4Prefix":
                writer.uint32(240).bool(message.wellKnown.ipv4Prefix);
                break;
            case "ipv6Prefix":
                writer.uint32(248).bool(message.wellKnown.ipv6Prefix);
                break;
            case "hostAndPort":
                writer.uint32(256).bool(message.wellKnown.hostAndPort);
                break;
            case "wellKnownRegex":
                writer.uint32(192).int32(message.wellKnown.wellKnownRegex);
                break;
        }
        if (message.strict !== undefined && message.strict !== false) {
            writer.uint32(200).bool(message.strict);
        }
        for (const v of message.example) {
            writer.uint32(274).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStringRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.const = reader.string();
                    continue;
                }
                case 19: {
                    if (tag !== 152) {
                        break;
                    }
                    message.len = reader.uint64().toString();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.minLen = reader.uint64().toString();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.maxLen = reader.uint64().toString();
                    continue;
                }
                case 20: {
                    if (tag !== 160) {
                        break;
                    }
                    message.lenBytes = reader.uint64().toString();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.minBytes = reader.uint64().toString();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.maxBytes = reader.uint64().toString();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.pattern = reader.string();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.prefix = reader.string();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.suffix = reader.string();
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.contains = reader.string();
                    continue;
                }
                case 23: {
                    if (tag !== 186) {
                        break;
                    }
                    message.notContains = reader.string();
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    message.in.push(reader.string());
                    continue;
                }
                case 11: {
                    if (tag !== 90) {
                        break;
                    }
                    message.notIn.push(reader.string());
                    continue;
                }
                case 12: {
                    if (tag !== 96) {
                        break;
                    }
                    message.wellKnown = { $case: "email", email: reader.bool() };
                    continue;
                }
                case 13: {
                    if (tag !== 104) {
                        break;
                    }
                    message.wellKnown = { $case: "hostname", hostname: reader.bool() };
                    continue;
                }
                case 14: {
                    if (tag !== 112) {
                        break;
                    }
                    message.wellKnown = { $case: "ip", ip: reader.bool() };
                    continue;
                }
                case 15: {
                    if (tag !== 120) {
                        break;
                    }
                    message.wellKnown = { $case: "ipv4", ipv4: reader.bool() };
                    continue;
                }
                case 16: {
                    if (tag !== 128) {
                        break;
                    }
                    message.wellKnown = { $case: "ipv6", ipv6: reader.bool() };
                    continue;
                }
                case 17: {
                    if (tag !== 136) {
                        break;
                    }
                    message.wellKnown = { $case: "uri", uri: reader.bool() };
                    continue;
                }
                case 18: {
                    if (tag !== 144) {
                        break;
                    }
                    message.wellKnown = { $case: "uriRef", uriRef: reader.bool() };
                    continue;
                }
                case 21: {
                    if (tag !== 168) {
                        break;
                    }
                    message.wellKnown = { $case: "address", address: reader.bool() };
                    continue;
                }
                case 22: {
                    if (tag !== 176) {
                        break;
                    }
                    message.wellKnown = { $case: "uuid", uuid: reader.bool() };
                    continue;
                }
                case 33: {
                    if (tag !== 264) {
                        break;
                    }
                    message.wellKnown = { $case: "tuuid", tuuid: reader.bool() };
                    continue;
                }
                case 26: {
                    if (tag !== 208) {
                        break;
                    }
                    message.wellKnown = {
                        $case: "ipWithPrefixlen",
                        ipWithPrefixlen: reader.bool(),
                    };
                    continue;
                }
                case 27: {
                    if (tag !== 216) {
                        break;
                    }
                    message.wellKnown = {
                        $case: "ipv4WithPrefixlen",
                        ipv4WithPrefixlen: reader.bool(),
                    };
                    continue;
                }
                case 28: {
                    if (tag !== 224) {
                        break;
                    }
                    message.wellKnown = {
                        $case: "ipv6WithPrefixlen",
                        ipv6WithPrefixlen: reader.bool(),
                    };
                    continue;
                }
                case 29: {
                    if (tag !== 232) {
                        break;
                    }
                    message.wellKnown = { $case: "ipPrefix", ipPrefix: reader.bool() };
                    continue;
                }
                case 30: {
                    if (tag !== 240) {
                        break;
                    }
                    message.wellKnown = {
                        $case: "ipv4Prefix",
                        ipv4Prefix: reader.bool(),
                    };
                    continue;
                }
                case 31: {
                    if (tag !== 248) {
                        break;
                    }
                    message.wellKnown = {
                        $case: "ipv6Prefix",
                        ipv6Prefix: reader.bool(),
                    };
                    continue;
                }
                case 32: {
                    if (tag !== 256) {
                        break;
                    }
                    message.wellKnown = {
                        $case: "hostAndPort",
                        hostAndPort: reader.bool(),
                    };
                    continue;
                }
                case 24: {
                    if (tag !== 192) {
                        break;
                    }
                    message.wellKnown = {
                        $case: "wellKnownRegex",
                        wellKnownRegex: reader.int32(),
                    };
                    continue;
                }
                case 25: {
                    if (tag !== 200) {
                        break;
                    }
                    message.strict = reader.bool();
                    continue;
                }
                case 34: {
                    if (tag !== 274) {
                        break;
                    }
                    message.example.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseBytesRules() {
    return {
        const: new Uint8Array(0),
        len: "0",
        minLen: "0",
        maxLen: "0",
        pattern: "",
        prefix: new Uint8Array(0),
        suffix: new Uint8Array(0),
        contains: new Uint8Array(0),
        in: [],
        notIn: [],
        wellKnown: undefined,
        example: [],
    };
}
exports.BytesRules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined && message.const.length !== 0) {
            writer.uint32(10).bytes(message.const);
        }
        if (message.len !== undefined && message.len !== "0") {
            writer.uint32(104).uint64(message.len);
        }
        if (message.minLen !== undefined && message.minLen !== "0") {
            writer.uint32(16).uint64(message.minLen);
        }
        if (message.maxLen !== undefined && message.maxLen !== "0") {
            writer.uint32(24).uint64(message.maxLen);
        }
        if (message.pattern !== undefined && message.pattern !== "") {
            writer.uint32(34).string(message.pattern);
        }
        if (message.prefix !== undefined && message.prefix.length !== 0) {
            writer.uint32(42).bytes(message.prefix);
        }
        if (message.suffix !== undefined && message.suffix.length !== 0) {
            writer.uint32(50).bytes(message.suffix);
        }
        if (message.contains !== undefined && message.contains.length !== 0) {
            writer.uint32(58).bytes(message.contains);
        }
        for (const v of message.in) {
            writer.uint32(66).bytes(v);
        }
        for (const v of message.notIn) {
            writer.uint32(74).bytes(v);
        }
        switch (message.wellKnown?.$case) {
            case "ip":
                writer.uint32(80).bool(message.wellKnown.ip);
                break;
            case "ipv4":
                writer.uint32(88).bool(message.wellKnown.ipv4);
                break;
            case "ipv6":
                writer.uint32(96).bool(message.wellKnown.ipv6);
                break;
        }
        for (const v of message.example) {
            writer.uint32(114).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBytesRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.const = reader.bytes();
                    continue;
                }
                case 13: {
                    if (tag !== 104) {
                        break;
                    }
                    message.len = reader.uint64().toString();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.minLen = reader.uint64().toString();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.maxLen = reader.uint64().toString();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.pattern = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.prefix = reader.bytes();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.suffix = reader.bytes();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.contains = reader.bytes();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.in.push(reader.bytes());
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.notIn.push(reader.bytes());
                    continue;
                }
                case 10: {
                    if (tag !== 80) {
                        break;
                    }
                    message.wellKnown = { $case: "ip", ip: reader.bool() };
                    continue;
                }
                case 11: {
                    if (tag !== 88) {
                        break;
                    }
                    message.wellKnown = { $case: "ipv4", ipv4: reader.bool() };
                    continue;
                }
                case 12: {
                    if (tag !== 96) {
                        break;
                    }
                    message.wellKnown = { $case: "ipv6", ipv6: reader.bool() };
                    continue;
                }
                case 14: {
                    if (tag !== 114) {
                        break;
                    }
                    message.example.push(reader.bytes());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseEnumRules() {
    return { const: 0, definedOnly: false, in: [], notIn: [], example: [] };
}
exports.EnumRules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined && message.const !== 0) {
            writer.uint32(8).int32(message.const);
        }
        if (message.definedOnly !== undefined && message.definedOnly !== false) {
            writer.uint32(16).bool(message.definedOnly);
        }
        writer.uint32(26).fork();
        for (const v of message.in) {
            writer.int32(v);
        }
        writer.join();
        writer.uint32(34).fork();
        for (const v of message.notIn) {
            writer.int32(v);
        }
        writer.join();
        writer.uint32(42).fork();
        for (const v of message.example) {
            writer.int32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEnumRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.const = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.definedOnly = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag === 24) {
                        message.in.push(reader.int32());
                        continue;
                    }
                    if (tag === 26) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 4: {
                    if (tag === 32) {
                        message.notIn.push(reader.int32());
                        continue;
                    }
                    if (tag === 34) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 5: {
                    if (tag === 40) {
                        message.example.push(reader.int32());
                        continue;
                    }
                    if (tag === 42) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.example.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseRepeatedRules() {
    return { minItems: "0", maxItems: "0", unique: false, items: undefined };
}
exports.RepeatedRules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.minItems !== undefined && message.minItems !== "0") {
            writer.uint32(8).uint64(message.minItems);
        }
        if (message.maxItems !== undefined && message.maxItems !== "0") {
            writer.uint32(16).uint64(message.maxItems);
        }
        if (message.unique !== undefined && message.unique !== false) {
            writer.uint32(24).bool(message.unique);
        }
        if (message.items !== undefined) {
            exports.FieldRules.encode(message.items, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRepeatedRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.minItems = reader.uint64().toString();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.maxItems = reader.uint64().toString();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.unique = reader.bool();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.items = exports.FieldRules.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseMapRules() {
    return { minPairs: "0", maxPairs: "0", keys: undefined, values: undefined };
}
exports.MapRules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.minPairs !== undefined && message.minPairs !== "0") {
            writer.uint32(8).uint64(message.minPairs);
        }
        if (message.maxPairs !== undefined && message.maxPairs !== "0") {
            writer.uint32(16).uint64(message.maxPairs);
        }
        if (message.keys !== undefined) {
            exports.FieldRules.encode(message.keys, writer.uint32(34).fork()).join();
        }
        if (message.values !== undefined) {
            exports.FieldRules.encode(message.values, writer.uint32(42).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.minPairs = reader.uint64().toString();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.maxPairs = reader.uint64().toString();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.keys = exports.FieldRules.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.values = exports.FieldRules.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseAnyRules() {
    return { in: [], notIn: [] };
}
exports.AnyRules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.in) {
            writer.uint32(18).string(v);
        }
        for (const v of message.notIn) {
            writer.uint32(26).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAnyRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.in.push(reader.string());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.notIn.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseDurationRules() {
    return {
        const: undefined,
        lessThan: undefined,
        greaterThan: undefined,
        in: [],
        notIn: [],
        example: [],
    };
}
exports.DurationRules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined) {
            duration_1.Duration.encode(message.const, writer.uint32(18).fork()).join();
        }
        switch (message.lessThan?.$case) {
            case "lt":
                duration_1.Duration.encode(message.lessThan.lt, writer.uint32(26).fork()).join();
                break;
            case "lte":
                duration_1.Duration.encode(message.lessThan.lte, writer.uint32(34).fork()).join();
                break;
        }
        switch (message.greaterThan?.$case) {
            case "gt":
                duration_1.Duration.encode(message.greaterThan.gt, writer.uint32(42).fork()).join();
                break;
            case "gte":
                duration_1.Duration.encode(message.greaterThan.gte, writer.uint32(50).fork()).join();
                break;
        }
        for (const v of message.in) {
            duration_1.Duration.encode(v, writer.uint32(58).fork()).join();
        }
        for (const v of message.notIn) {
            duration_1.Duration.encode(v, writer.uint32(66).fork()).join();
        }
        for (const v of message.example) {
            duration_1.Duration.encode(v, writer.uint32(74).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDurationRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.const = duration_1.Duration.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.lessThan = {
                        $case: "lt",
                        lt: duration_1.Duration.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.lessThan = {
                        $case: "lte",
                        lte: duration_1.Duration.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.greaterThan = {
                        $case: "gt",
                        gt: duration_1.Duration.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.greaterThan = {
                        $case: "gte",
                        gte: duration_1.Duration.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.in.push(duration_1.Duration.decode(reader, reader.uint32()));
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.notIn.push(duration_1.Duration.decode(reader, reader.uint32()));
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.example.push(duration_1.Duration.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseTimestampRules() {
    return {
        const: undefined,
        lessThan: undefined,
        greaterThan: undefined,
        within: undefined,
        example: [],
    };
}
exports.TimestampRules = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.const !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.const), writer.uint32(18).fork()).join();
        }
        switch (message.lessThan?.$case) {
            case "lt":
                timestamp_1.Timestamp.encode(toTimestamp(message.lessThan.lt), writer.uint32(26).fork()).join();
                break;
            case "lte":
                timestamp_1.Timestamp.encode(toTimestamp(message.lessThan.lte), writer.uint32(34).fork()).join();
                break;
            case "ltNow":
                writer.uint32(56).bool(message.lessThan.ltNow);
                break;
        }
        switch (message.greaterThan?.$case) {
            case "gt":
                timestamp_1.Timestamp.encode(toTimestamp(message.greaterThan.gt), writer.uint32(42).fork()).join();
                break;
            case "gte":
                timestamp_1.Timestamp.encode(toTimestamp(message.greaterThan.gte), writer.uint32(50).fork()).join();
                break;
            case "gtNow":
                writer.uint32(64).bool(message.greaterThan.gtNow);
                break;
        }
        if (message.within !== undefined) {
            duration_1.Duration.encode(message.within, writer.uint32(74).fork()).join();
        }
        for (const v of message.example) {
            timestamp_1.Timestamp.encode(toTimestamp(v), writer.uint32(82).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTimestampRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.const = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.lessThan = {
                        $case: "lt",
                        lt: fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32())),
                    };
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.lessThan = {
                        $case: "lte",
                        lte: fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32())),
                    };
                    continue;
                }
                case 7: {
                    if (tag !== 56) {
                        break;
                    }
                    message.lessThan = { $case: "ltNow", ltNow: reader.bool() };
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.greaterThan = {
                        $case: "gt",
                        gt: fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32())),
                    };
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.greaterThan = {
                        $case: "gte",
                        gte: fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32())),
                    };
                    continue;
                }
                case 8: {
                    if (tag !== 64) {
                        break;
                    }
                    message.greaterThan = { $case: "gtNow", gtNow: reader.bool() };
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.within = duration_1.Duration.decode(reader, reader.uint32());
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    message.example.push(fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32())));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1_000).toString();
    const nanos = (date.getTime() % 1_000) * 1_000_000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
    millis += (t.nanos || 0) / 1_000_000;
    return new globalThis.Date(millis);
}
//# sourceMappingURL=validate.js.map