"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// source: cerbos/policy/v1/policy.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.Schemas_Schema = exports.Schemas_IgnoreWhen = exports.Schemas = exports.Output_When = exports.Output = exports.Match_ExprList = exports.Match = exports.Condition = exports.Variables_LocalEntry = exports.Variables = exports.ExportVariables_DefinitionsEntry = exports.ExportVariables = exports.Constants_LocalEntry = exports.Constants = exports.ExportConstants_DefinitionsEntry = exports.ExportConstants = exports.RoleDef = exports.DerivedRoles = exports.PrincipalRule_Action = exports.PrincipalRule = exports.PrincipalPolicy = exports.RoleRule = exports.RolePolicy = exports.ResourceRule = exports.ResourcePolicy = exports.Metadata_AnnotationsEntry = exports.Metadata = exports.SourceAttributes_AttributesEntry = exports.SourceAttributes = exports.Policy_VariablesEntry = exports.Policy = exports.ScopePermissions = exports.protobufPackage = void 0;
/* eslint-disable */
const wire_1 = require("@bufbuild/protobuf/wire");
const struct_1 = require("../../../google/protobuf/struct");
const wrappers_1 = require("../../../google/protobuf/wrappers");
exports.protobufPackage = "cerbos.policy.v1";
var ScopePermissions;
(function (ScopePermissions) {
    ScopePermissions[ScopePermissions["SCOPE_PERMISSIONS_UNSPECIFIED"] = 0] = "SCOPE_PERMISSIONS_UNSPECIFIED";
    ScopePermissions[ScopePermissions["SCOPE_PERMISSIONS_OVERRIDE_PARENT"] = 1] = "SCOPE_PERMISSIONS_OVERRIDE_PARENT";
    ScopePermissions[ScopePermissions["SCOPE_PERMISSIONS_REQUIRE_PARENTAL_CONSENT_FOR_ALLOWS"] = 2] = "SCOPE_PERMISSIONS_REQUIRE_PARENTAL_CONSENT_FOR_ALLOWS";
})(ScopePermissions || (exports.ScopePermissions = ScopePermissions = {}));
function createBasePolicy() {
    return {
        apiVersion: "",
        disabled: false,
        description: "",
        metadata: undefined,
        policyType: undefined,
        variables: {},
        jsonSchema: "",
    };
}
exports.Policy = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.apiVersion !== "") {
            writer.uint32(10).string(message.apiVersion);
        }
        if (message.disabled !== false) {
            writer.uint32(16).bool(message.disabled);
        }
        if (message.description !== "") {
            writer.uint32(26).string(message.description);
        }
        if (message.metadata !== undefined) {
            exports.Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
        }
        switch (message.policyType?.$case) {
            case "resourcePolicy":
                exports.ResourcePolicy.encode(message.policyType.resourcePolicy, writer.uint32(42).fork()).join();
                break;
            case "principalPolicy":
                exports.PrincipalPolicy.encode(message.policyType.principalPolicy, writer.uint32(50).fork()).join();
                break;
            case "derivedRoles":
                exports.DerivedRoles.encode(message.policyType.derivedRoles, writer.uint32(58).fork()).join();
                break;
            case "exportVariables":
                exports.ExportVariables.encode(message.policyType.exportVariables, writer.uint32(82).fork()).join();
                break;
            case "rolePolicy":
                exports.RolePolicy.encode(message.policyType.rolePolicy, writer.uint32(90).fork()).join();
                break;
            case "exportConstants":
                exports.ExportConstants.encode(message.policyType.exportConstants, writer.uint32(98).fork()).join();
                break;
        }
        Object.entries(message.variables).forEach(([key, value]) => {
            exports.Policy_VariablesEntry.encode({ key: key, value }, writer.uint32(66).fork()).join();
        });
        if (message.jsonSchema !== "") {
            writer.uint32(74).string(message.jsonSchema);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePolicy();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.apiVersion = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.disabled = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.metadata = exports.Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.policyType = {
                        $case: "resourcePolicy",
                        resourcePolicy: exports.ResourcePolicy.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.policyType = {
                        $case: "principalPolicy",
                        principalPolicy: exports.PrincipalPolicy.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.policyType = {
                        $case: "derivedRoles",
                        derivedRoles: exports.DerivedRoles.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    message.policyType = {
                        $case: "exportVariables",
                        exportVariables: exports.ExportVariables.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 11: {
                    if (tag !== 90) {
                        break;
                    }
                    message.policyType = {
                        $case: "rolePolicy",
                        rolePolicy: exports.RolePolicy.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 12: {
                    if (tag !== 98) {
                        break;
                    }
                    message.policyType = {
                        $case: "exportConstants",
                        exportConstants: exports.ExportConstants.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    const entry8 = exports.Policy_VariablesEntry.decode(reader, reader.uint32());
                    if (entry8.value !== undefined) {
                        message.variables[entry8.key] = entry8.value;
                    }
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.jsonSchema = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBasePolicy_VariablesEntry() {
    return { key: "", value: "" };
}
exports.Policy_VariablesEntry = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePolicy_VariablesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseSourceAttributes() {
    return { attributes: {} };
}
exports.SourceAttributes = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        Object.entries(message.attributes).forEach(([key, value]) => {
            if (value !== undefined) {
                exports.SourceAttributes_AttributesEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
            }
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSourceAttributes();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = exports.SourceAttributes_AttributesEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.attributes[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseSourceAttributes_AttributesEntry() {
    return { key: "", value: undefined };
}
exports.SourceAttributes_AttributesEntry = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            struct_1.Value.encode(struct_1.Value.wrap(message.value), writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSourceAttributes_AttributesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = struct_1.Value.unwrap(struct_1.Value.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseMetadata() {
    return {
        sourceFile: "",
        annotations: {},
        hash: undefined,
        storeIdentifer: "",
        storeIdentifier: "",
        sourceAttributes: undefined,
    };
}
exports.Metadata = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.sourceFile !== "") {
            writer.uint32(10).string(message.sourceFile);
        }
        Object.entries(message.annotations).forEach(([key, value]) => {
            exports.Metadata_AnnotationsEntry.encode({ key: key, value }, writer.uint32(18).fork()).join();
        });
        if (message.hash !== undefined) {
            wrappers_1.UInt64Value.encode({ value: message.hash }, writer.uint32(26).fork()).join();
        }
        if (message.storeIdentifer !== "") {
            writer.uint32(34).string(message.storeIdentifer);
        }
        if (message.storeIdentifier !== "") {
            writer.uint32(42).string(message.storeIdentifier);
        }
        if (message.sourceAttributes !== undefined) {
            exports.SourceAttributes.encode(message.sourceAttributes, writer.uint32(50).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMetadata();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.sourceFile = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = exports.Metadata_AnnotationsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.annotations[entry2.key] = entry2.value;
                    }
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.hash = wrappers_1.UInt64Value.decode(reader, reader.uint32()).value;
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.storeIdentifer = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.storeIdentifier = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.sourceAttributes = exports.SourceAttributes.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseMetadata_AnnotationsEntry() {
    return { key: "", value: "" };
}
exports.Metadata_AnnotationsEntry = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMetadata_AnnotationsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseResourcePolicy() {
    return {
        resource: "",
        version: "",
        importDerivedRoles: [],
        rules: [],
        scope: "",
        schemas: undefined,
        variables: undefined,
        scopePermissions: 0,
        constants: undefined,
    };
}
exports.ResourcePolicy = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.resource !== "") {
            writer.uint32(10).string(message.resource);
        }
        if (message.version !== "") {
            writer.uint32(18).string(message.version);
        }
        for (const v of message.importDerivedRoles) {
            writer.uint32(26).string(v);
        }
        for (const v of message.rules) {
            exports.ResourceRule.encode(v, writer.uint32(34).fork()).join();
        }
        if (message.scope !== "") {
            writer.uint32(42).string(message.scope);
        }
        if (message.schemas !== undefined) {
            exports.Schemas.encode(message.schemas, writer.uint32(50).fork()).join();
        }
        if (message.variables !== undefined) {
            exports.Variables.encode(message.variables, writer.uint32(58).fork()).join();
        }
        if (message.scopePermissions !== 0) {
            writer.uint32(64).int32(message.scopePermissions);
        }
        if (message.constants !== undefined) {
            exports.Constants.encode(message.constants, writer.uint32(74).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResourcePolicy();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.resource = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.importDerivedRoles.push(reader.string());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.rules.push(exports.ResourceRule.decode(reader, reader.uint32()));
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.scope = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.schemas = exports.Schemas.decode(reader, reader.uint32());
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.variables = exports.Variables.decode(reader, reader.uint32());
                    continue;
                }
                case 8: {
                    if (tag !== 64) {
                        break;
                    }
                    message.scopePermissions = reader.int32();
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.constants = exports.Constants.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseResourceRule() {
    return {
        actions: [],
        derivedRoles: [],
        roles: [],
        condition: undefined,
        effect: 0,
        name: "",
        output: undefined,
    };
}
exports.ResourceRule = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.actions) {
            writer.uint32(10).string(v);
        }
        for (const v of message.derivedRoles) {
            writer.uint32(18).string(v);
        }
        for (const v of message.roles) {
            writer.uint32(26).string(v);
        }
        if (message.condition !== undefined) {
            exports.Condition.encode(message.condition, writer.uint32(34).fork()).join();
        }
        if (message.effect !== 0) {
            writer.uint32(40).int32(message.effect);
        }
        if (message.name !== "") {
            writer.uint32(50).string(message.name);
        }
        if (message.output !== undefined) {
            exports.Output.encode(message.output, writer.uint32(58).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResourceRule();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.actions.push(reader.string());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.derivedRoles.push(reader.string());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.roles.push(reader.string());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.condition = exports.Condition.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.effect = reader.int32();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.output = exports.Output.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseRolePolicy() {
    return {
        policyType: undefined,
        parentRoles: [],
        scope: "",
        rules: [],
        scopePermissions: 0,
    };
}
exports.RolePolicy = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        switch (message.policyType?.$case) {
            case "role":
                writer.uint32(10).string(message.policyType.role);
                break;
        }
        for (const v of message.parentRoles) {
            writer.uint32(42).string(v);
        }
        if (message.scope !== "") {
            writer.uint32(18).string(message.scope);
        }
        for (const v of message.rules) {
            exports.RoleRule.encode(v, writer.uint32(26).fork()).join();
        }
        if (message.scopePermissions !== 0) {
            writer.uint32(32).int32(message.scopePermissions);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRolePolicy();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.policyType = { $case: "role", role: reader.string() };
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.parentRoles.push(reader.string());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.scope = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.rules.push(exports.RoleRule.decode(reader, reader.uint32()));
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.scopePermissions = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseRoleRule() {
    return { resource: "", allowActions: [], condition: undefined };
}
exports.RoleRule = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.resource !== "") {
            writer.uint32(10).string(message.resource);
        }
        for (const v of message.allowActions) {
            writer.uint32(18).string(v);
        }
        if (message.condition !== undefined) {
            exports.Condition.encode(message.condition, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRoleRule();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.resource = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.allowActions.push(reader.string());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.condition = exports.Condition.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBasePrincipalPolicy() {
    return {
        principal: "",
        version: "",
        rules: [],
        scope: "",
        variables: undefined,
        scopePermissions: 0,
        constants: undefined,
    };
}
exports.PrincipalPolicy = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.principal !== "") {
            writer.uint32(10).string(message.principal);
        }
        if (message.version !== "") {
            writer.uint32(18).string(message.version);
        }
        for (const v of message.rules) {
            exports.PrincipalRule.encode(v, writer.uint32(26).fork()).join();
        }
        if (message.scope !== "") {
            writer.uint32(34).string(message.scope);
        }
        if (message.variables !== undefined) {
            exports.Variables.encode(message.variables, writer.uint32(42).fork()).join();
        }
        if (message.scopePermissions !== 0) {
            writer.uint32(48).int32(message.scopePermissions);
        }
        if (message.constants !== undefined) {
            exports.Constants.encode(message.constants, writer.uint32(58).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrincipalPolicy();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.principal = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.rules.push(exports.PrincipalRule.decode(reader, reader.uint32()));
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.scope = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.variables = exports.Variables.decode(reader, reader.uint32());
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }
                    message.scopePermissions = reader.int32();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.constants = exports.Constants.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBasePrincipalRule() {
    return { resource: "", actions: [] };
}
exports.PrincipalRule = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.resource !== "") {
            writer.uint32(10).string(message.resource);
        }
        for (const v of message.actions) {
            exports.PrincipalRule_Action.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrincipalRule();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.resource = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.actions.push(exports.PrincipalRule_Action.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBasePrincipalRule_Action() {
    return {
        action: "",
        condition: undefined,
        effect: 0,
        name: "",
        output: undefined,
    };
}
exports.PrincipalRule_Action = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.action !== "") {
            writer.uint32(10).string(message.action);
        }
        if (message.condition !== undefined) {
            exports.Condition.encode(message.condition, writer.uint32(18).fork()).join();
        }
        if (message.effect !== 0) {
            writer.uint32(24).int32(message.effect);
        }
        if (message.name !== "") {
            writer.uint32(34).string(message.name);
        }
        if (message.output !== undefined) {
            exports.Output.encode(message.output, writer.uint32(42).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrincipalRule_Action();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.action = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.condition = exports.Condition.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.effect = reader.int32();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.output = exports.Output.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseDerivedRoles() {
    return {
        name: "",
        definitions: [],
        variables: undefined,
        constants: undefined,
    };
}
exports.DerivedRoles = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        for (const v of message.definitions) {
            exports.RoleDef.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.variables !== undefined) {
            exports.Variables.encode(message.variables, writer.uint32(26).fork()).join();
        }
        if (message.constants !== undefined) {
            exports.Constants.encode(message.constants, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDerivedRoles();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.definitions.push(exports.RoleDef.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.variables = exports.Variables.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.constants = exports.Constants.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseRoleDef() {
    return { name: "", parentRoles: [], condition: undefined };
}
exports.RoleDef = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        for (const v of message.parentRoles) {
            writer.uint32(18).string(v);
        }
        if (message.condition !== undefined) {
            exports.Condition.encode(message.condition, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRoleDef();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.parentRoles.push(reader.string());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.condition = exports.Condition.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseExportConstants() {
    return { name: "", definitions: {} };
}
exports.ExportConstants = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        Object.entries(message.definitions).forEach(([key, value]) => {
            if (value !== undefined) {
                exports.ExportConstants_DefinitionsEntry.encode({ key: key, value }, writer.uint32(18).fork()).join();
            }
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExportConstants();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = exports.ExportConstants_DefinitionsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.definitions[entry2.key] = entry2.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseExportConstants_DefinitionsEntry() {
    return { key: "", value: undefined };
}
exports.ExportConstants_DefinitionsEntry = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            struct_1.Value.encode(struct_1.Value.wrap(message.value), writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExportConstants_DefinitionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = struct_1.Value.unwrap(struct_1.Value.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseConstants() {
    return { import: [], local: {} };
}
exports.Constants = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.import) {
            writer.uint32(10).string(v);
        }
        Object.entries(message.local).forEach(([key, value]) => {
            if (value !== undefined) {
                exports.Constants_LocalEntry.encode({ key: key, value }, writer.uint32(18).fork()).join();
            }
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConstants();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.import.push(reader.string());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = exports.Constants_LocalEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.local[entry2.key] = entry2.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseConstants_LocalEntry() {
    return { key: "", value: undefined };
}
exports.Constants_LocalEntry = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            struct_1.Value.encode(struct_1.Value.wrap(message.value), writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConstants_LocalEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = struct_1.Value.unwrap(struct_1.Value.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseExportVariables() {
    return { name: "", definitions: {} };
}
exports.ExportVariables = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        Object.entries(message.definitions).forEach(([key, value]) => {
            exports.ExportVariables_DefinitionsEntry.encode({ key: key, value }, writer.uint32(18).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExportVariables();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = exports.ExportVariables_DefinitionsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.definitions[entry2.key] = entry2.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseExportVariables_DefinitionsEntry() {
    return { key: "", value: "" };
}
exports.ExportVariables_DefinitionsEntry = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExportVariables_DefinitionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseVariables() {
    return { import: [], local: {} };
}
exports.Variables = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.import) {
            writer.uint32(10).string(v);
        }
        Object.entries(message.local).forEach(([key, value]) => {
            exports.Variables_LocalEntry.encode({ key: key, value }, writer.uint32(18).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVariables();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.import.push(reader.string());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = exports.Variables_LocalEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.local[entry2.key] = entry2.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseVariables_LocalEntry() {
    return { key: "", value: "" };
}
exports.Variables_LocalEntry = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVariables_LocalEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseCondition() {
    return { condition: undefined };
}
exports.Condition = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        switch (message.condition?.$case) {
            case "match":
                exports.Match.encode(message.condition.match, writer.uint32(10).fork()).join();
                break;
            case "script":
                writer.uint32(18).string(message.condition.script);
                break;
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCondition();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.condition = {
                        $case: "match",
                        match: exports.Match.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.condition = { $case: "script", script: reader.string() };
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseMatch() {
    return { op: undefined };
}
exports.Match = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        switch (message.op?.$case) {
            case "all":
                exports.Match_ExprList.encode(message.op.all, writer.uint32(10).fork()).join();
                break;
            case "any":
                exports.Match_ExprList.encode(message.op.any, writer.uint32(18).fork()).join();
                break;
            case "none":
                exports.Match_ExprList.encode(message.op.none, writer.uint32(26).fork()).join();
                break;
            case "expr":
                writer.uint32(34).string(message.op.expr);
                break;
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMatch();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.op = {
                        $case: "all",
                        all: exports.Match_ExprList.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.op = {
                        $case: "any",
                        any: exports.Match_ExprList.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.op = {
                        $case: "none",
                        none: exports.Match_ExprList.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.op = { $case: "expr", expr: reader.string() };
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseMatch_ExprList() {
    return { of: [] };
}
exports.Match_ExprList = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.of) {
            exports.Match.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMatch_ExprList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.of.push(exports.Match.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseOutput() {
    return { expr: "", when: undefined };
}
exports.Output = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.expr !== "") {
            writer.uint32(10).string(message.expr);
        }
        if (message.when !== undefined) {
            exports.Output_When.encode(message.when, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOutput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.expr = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.when = exports.Output_When.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseOutput_When() {
    return { ruleActivated: "", conditionNotMet: "" };
}
exports.Output_When = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.ruleActivated !== "") {
            writer.uint32(10).string(message.ruleActivated);
        }
        if (message.conditionNotMet !== "") {
            writer.uint32(18).string(message.conditionNotMet);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOutput_When();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.ruleActivated = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.conditionNotMet = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseSchemas() {
    return { principalSchema: undefined, resourceSchema: undefined };
}
exports.Schemas = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.principalSchema !== undefined) {
            exports.Schemas_Schema.encode(message.principalSchema, writer.uint32(10).fork()).join();
        }
        if (message.resourceSchema !== undefined) {
            exports.Schemas_Schema.encode(message.resourceSchema, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSchemas();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.principalSchema = exports.Schemas_Schema.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.resourceSchema = exports.Schemas_Schema.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseSchemas_IgnoreWhen() {
    return { actions: [] };
}
exports.Schemas_IgnoreWhen = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.actions) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSchemas_IgnoreWhen();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.actions.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseSchemas_Schema() {
    return { ref: "", ignoreWhen: undefined };
}
exports.Schemas_Schema = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.ref !== "") {
            writer.uint32(10).string(message.ref);
        }
        if (message.ignoreWhen !== undefined) {
            exports.Schemas_IgnoreWhen.encode(message.ignoreWhen, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSchemas_Schema();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.ref = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.ignoreWhen = exports.Schemas_IgnoreWhen.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
//# sourceMappingURL=policy.js.map