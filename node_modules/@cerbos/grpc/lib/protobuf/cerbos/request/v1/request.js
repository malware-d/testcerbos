"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// source: cerbos/request/v1/request.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReloadStoreRequest = exports.DeleteSchemaRequest = exports.GetSchemaRequest = exports.ListSchemasRequest = exports.AddOrUpdateSchemaRequest = exports.InspectPoliciesRequest = exports.EnablePolicyRequest = exports.DisablePolicyRequest = exports.GetPolicyRequest = exports.ListPoliciesRequest = exports.ServerInfoRequest = exports.ListAuditLogEntriesRequest_TimeRange = exports.ListAuditLogEntriesRequest = exports.AddOrUpdatePolicyRequest = exports.AuxData_JWT = exports.AuxData = exports.CheckResourcesRequest_ResourceEntry = exports.CheckResourcesRequest = exports.CheckResourceBatchRequest_BatchEntry = exports.CheckResourceBatchRequest = exports.AttributesMap_AttrEntry = exports.AttributesMap = exports.ResourceSet_InstancesEntry = exports.ResourceSet = exports.CheckResourceSetRequest = exports.PlanResourcesRequest = exports.ListAuditLogEntriesRequest_Kind = exports.protobufPackage = void 0;
/* eslint-disable */
const wire_1 = require("@bufbuild/protobuf/wire");
const duration_1 = require("../../../google/protobuf/duration");
const struct_1 = require("../../../google/protobuf/struct");
const timestamp_1 = require("../../../google/protobuf/timestamp");
const engine_1 = require("../../engine/v1/engine");
const policy_1 = require("../../policy/v1/policy");
const schema_1 = require("../../schema/v1/schema");
exports.protobufPackage = "cerbos.request.v1";
var ListAuditLogEntriesRequest_Kind;
(function (ListAuditLogEntriesRequest_Kind) {
    ListAuditLogEntriesRequest_Kind[ListAuditLogEntriesRequest_Kind["KIND_UNSPECIFIED"] = 0] = "KIND_UNSPECIFIED";
    ListAuditLogEntriesRequest_Kind[ListAuditLogEntriesRequest_Kind["KIND_ACCESS"] = 1] = "KIND_ACCESS";
    ListAuditLogEntriesRequest_Kind[ListAuditLogEntriesRequest_Kind["KIND_DECISION"] = 2] = "KIND_DECISION";
})(ListAuditLogEntriesRequest_Kind || (exports.ListAuditLogEntriesRequest_Kind = ListAuditLogEntriesRequest_Kind = {}));
function createBasePlanResourcesRequest() {
    return {
        requestId: "",
        action: "",
        actions: [],
        principal: undefined,
        resource: undefined,
        auxData: undefined,
        includeMeta: false,
    };
}
exports.PlanResourcesRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.requestId !== "") {
            writer.uint32(10).string(message.requestId);
        }
        if (message.action !== "") {
            writer.uint32(18).string(message.action);
        }
        for (const v of message.actions) {
            writer.uint32(58).string(v);
        }
        if (message.principal !== undefined) {
            engine_1.Principal.encode(message.principal, writer.uint32(26).fork()).join();
        }
        if (message.resource !== undefined) {
            engine_1.PlanResourcesInput_Resource.encode(message.resource, writer.uint32(34).fork()).join();
        }
        if (message.auxData !== undefined) {
            exports.AuxData.encode(message.auxData, writer.uint32(42).fork()).join();
        }
        if (message.includeMeta !== false) {
            writer.uint32(48).bool(message.includeMeta);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlanResourcesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.requestId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.action = reader.string();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.actions.push(reader.string());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.principal = engine_1.Principal.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.resource = engine_1.PlanResourcesInput_Resource.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.auxData = exports.AuxData.decode(reader, reader.uint32());
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }
                    message.includeMeta = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseCheckResourceSetRequest() {
    return {
        requestId: "",
        actions: [],
        principal: undefined,
        resource: undefined,
        includeMeta: false,
        auxData: undefined,
    };
}
exports.CheckResourceSetRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.requestId !== "") {
            writer.uint32(10).string(message.requestId);
        }
        for (const v of message.actions) {
            writer.uint32(18).string(v);
        }
        if (message.principal !== undefined) {
            engine_1.Principal.encode(message.principal, writer.uint32(26).fork()).join();
        }
        if (message.resource !== undefined) {
            exports.ResourceSet.encode(message.resource, writer.uint32(34).fork()).join();
        }
        if (message.includeMeta !== false) {
            writer.uint32(40).bool(message.includeMeta);
        }
        if (message.auxData !== undefined) {
            exports.AuxData.encode(message.auxData, writer.uint32(50).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceSetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.requestId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.actions.push(reader.string());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.principal = engine_1.Principal.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.resource = exports.ResourceSet.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.includeMeta = reader.bool();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.auxData = exports.AuxData.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseResourceSet() {
    return { kind: "", policyVersion: "", instances: {}, scope: "" };
}
exports.ResourceSet = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        if (message.policyVersion !== "") {
            writer.uint32(18).string(message.policyVersion);
        }
        Object.entries(message.instances).forEach(([key, value]) => {
            exports.ResourceSet_InstancesEntry.encode({ key: key, value }, writer.uint32(26).fork()).join();
        });
        if (message.scope !== "") {
            writer.uint32(34).string(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResourceSet();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.kind = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.policyVersion = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    const entry3 = exports.ResourceSet_InstancesEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.instances[entry3.key] = entry3.value;
                    }
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.scope = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseResourceSet_InstancesEntry() {
    return { key: "", value: undefined };
}
exports.ResourceSet_InstancesEntry = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.AttributesMap.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResourceSet_InstancesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = exports.AttributesMap.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseAttributesMap() {
    return { attr: {} };
}
exports.AttributesMap = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        Object.entries(message.attr).forEach(([key, value]) => {
            if (value !== undefined) {
                exports.AttributesMap_AttrEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
            }
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAttributesMap();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = exports.AttributesMap_AttrEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.attr[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseAttributesMap_AttrEntry() {
    return { key: "", value: undefined };
}
exports.AttributesMap_AttrEntry = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            struct_1.Value.encode(struct_1.Value.wrap(message.value), writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAttributesMap_AttrEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = struct_1.Value.unwrap(struct_1.Value.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseCheckResourceBatchRequest() {
    return {
        requestId: "",
        principal: undefined,
        resources: [],
        auxData: undefined,
    };
}
exports.CheckResourceBatchRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.requestId !== "") {
            writer.uint32(10).string(message.requestId);
        }
        if (message.principal !== undefined) {
            engine_1.Principal.encode(message.principal, writer.uint32(18).fork()).join();
        }
        for (const v of message.resources) {
            exports.CheckResourceBatchRequest_BatchEntry.encode(v, writer.uint32(26).fork()).join();
        }
        if (message.auxData !== undefined) {
            exports.AuxData.encode(message.auxData, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceBatchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.requestId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.principal = engine_1.Principal.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.resources.push(exports.CheckResourceBatchRequest_BatchEntry.decode(reader, reader.uint32()));
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.auxData = exports.AuxData.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseCheckResourceBatchRequest_BatchEntry() {
    return { actions: [], resource: undefined };
}
exports.CheckResourceBatchRequest_BatchEntry = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.actions) {
            writer.uint32(10).string(v);
        }
        if (message.resource !== undefined) {
            engine_1.Resource.encode(message.resource, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceBatchRequest_BatchEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.actions.push(reader.string());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.resource = engine_1.Resource.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseCheckResourcesRequest() {
    return {
        requestId: "",
        includeMeta: false,
        principal: undefined,
        resources: [],
        auxData: undefined,
    };
}
exports.CheckResourcesRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.requestId !== "") {
            writer.uint32(10).string(message.requestId);
        }
        if (message.includeMeta !== false) {
            writer.uint32(16).bool(message.includeMeta);
        }
        if (message.principal !== undefined) {
            engine_1.Principal.encode(message.principal, writer.uint32(26).fork()).join();
        }
        for (const v of message.resources) {
            exports.CheckResourcesRequest_ResourceEntry.encode(v, writer.uint32(34).fork()).join();
        }
        if (message.auxData !== undefined) {
            exports.AuxData.encode(message.auxData, writer.uint32(42).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourcesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.requestId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.includeMeta = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.principal = engine_1.Principal.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.resources.push(exports.CheckResourcesRequest_ResourceEntry.decode(reader, reader.uint32()));
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.auxData = exports.AuxData.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseCheckResourcesRequest_ResourceEntry() {
    return { actions: [], resource: undefined };
}
exports.CheckResourcesRequest_ResourceEntry = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.actions) {
            writer.uint32(10).string(v);
        }
        if (message.resource !== undefined) {
            engine_1.Resource.encode(message.resource, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourcesRequest_ResourceEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.actions.push(reader.string());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.resource = engine_1.Resource.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseAuxData() {
    return { jwt: undefined };
}
exports.AuxData = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.jwt !== undefined) {
            exports.AuxData_JWT.encode(message.jwt, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuxData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.jwt = exports.AuxData_JWT.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseAuxData_JWT() {
    return { token: "", keySetId: "" };
}
exports.AuxData_JWT = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.token !== "") {
            writer.uint32(10).string(message.token);
        }
        if (message.keySetId !== "") {
            writer.uint32(18).string(message.keySetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuxData_JWT();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.token = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.keySetId = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseAddOrUpdatePolicyRequest() {
    return { policies: [] };
}
exports.AddOrUpdatePolicyRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.policies) {
            policy_1.Policy.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddOrUpdatePolicyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.policies.push(policy_1.Policy.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseListAuditLogEntriesRequest() {
    return { kind: 0, filter: undefined };
}
exports.ListAuditLogEntriesRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.kind !== 0) {
            writer.uint32(8).int32(message.kind);
        }
        switch (message.filter?.$case) {
            case "tail":
                writer.uint32(16).uint32(message.filter.tail);
                break;
            case "between":
                exports.ListAuditLogEntriesRequest_TimeRange.encode(message.filter.between, writer.uint32(26).fork()).join();
                break;
            case "since":
                duration_1.Duration.encode(message.filter.since, writer.uint32(34).fork()).join();
                break;
            case "lookup":
                writer.uint32(42).string(message.filter.lookup);
                break;
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListAuditLogEntriesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.kind = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.filter = { $case: "tail", tail: reader.uint32() };
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.filter = {
                        $case: "between",
                        between: exports.ListAuditLogEntriesRequest_TimeRange.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.filter = {
                        $case: "since",
                        since: duration_1.Duration.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.filter = { $case: "lookup", lookup: reader.string() };
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseListAuditLogEntriesRequest_TimeRange() {
    return { start: undefined, end: undefined };
}
exports.ListAuditLogEntriesRequest_TimeRange = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.start !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.start), writer.uint32(10).fork()).join();
        }
        if (message.end !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.end), writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListAuditLogEntriesRequest_TimeRange();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.start = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.end = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseServerInfoRequest() {
    return {};
}
exports.ServerInfoRequest = {
    encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseServerInfoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseListPoliciesRequest() {
    return {
        includeDisabled: false,
        nameRegexp: "",
        scopeRegexp: "",
        versionRegexp: "",
        policyId: [],
    };
}
exports.ListPoliciesRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.includeDisabled !== false) {
            writer.uint32(8).bool(message.includeDisabled);
        }
        if (message.nameRegexp !== "") {
            writer.uint32(18).string(message.nameRegexp);
        }
        if (message.scopeRegexp !== "") {
            writer.uint32(26).string(message.scopeRegexp);
        }
        if (message.versionRegexp !== "") {
            writer.uint32(34).string(message.versionRegexp);
        }
        for (const v of message.policyId) {
            writer.uint32(42).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListPoliciesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.includeDisabled = reader.bool();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.nameRegexp = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.scopeRegexp = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.versionRegexp = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.policyId.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseGetPolicyRequest() {
    return { id: [] };
}
exports.GetPolicyRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.id) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPolicyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.id.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseDisablePolicyRequest() {
    return { id: [] };
}
exports.DisablePolicyRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.id) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDisablePolicyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.id.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseEnablePolicyRequest() {
    return { id: [] };
}
exports.EnablePolicyRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.id) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEnablePolicyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.id.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseInspectPoliciesRequest() {
    return {
        includeDisabled: false,
        nameRegexp: "",
        scopeRegexp: "",
        versionRegexp: "",
        policyId: [],
    };
}
exports.InspectPoliciesRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.includeDisabled !== false) {
            writer.uint32(8).bool(message.includeDisabled);
        }
        if (message.nameRegexp !== "") {
            writer.uint32(18).string(message.nameRegexp);
        }
        if (message.scopeRegexp !== "") {
            writer.uint32(26).string(message.scopeRegexp);
        }
        if (message.versionRegexp !== "") {
            writer.uint32(34).string(message.versionRegexp);
        }
        for (const v of message.policyId) {
            writer.uint32(42).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInspectPoliciesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.includeDisabled = reader.bool();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.nameRegexp = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.scopeRegexp = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.versionRegexp = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.policyId.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseAddOrUpdateSchemaRequest() {
    return { schemas: [] };
}
exports.AddOrUpdateSchemaRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.schemas) {
            schema_1.Schema.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddOrUpdateSchemaRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.schemas.push(schema_1.Schema.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseListSchemasRequest() {
    return {};
}
exports.ListSchemasRequest = {
    encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListSchemasRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseGetSchemaRequest() {
    return { id: [] };
}
exports.GetSchemaRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.id) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetSchemaRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.id.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseDeleteSchemaRequest() {
    return { id: [] };
}
exports.DeleteSchemaRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.id) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteSchemaRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.id.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseReloadStoreRequest() {
    return { wait: false };
}
exports.ReloadStoreRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.wait !== false) {
            writer.uint32(8).bool(message.wait);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseReloadStoreRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.wait = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1_000).toString();
    const nanos = (date.getTime() % 1_000) * 1_000_000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
    millis += (t.nanos || 0) / 1_000_000;
    return new globalThis.Date(millis);
}
//# sourceMappingURL=request.js.map